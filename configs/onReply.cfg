
onreply_route[MANAGE_REPLY] {

    xlog("L_NOTICE", "[MANAGE_REPLY] Received a stateful reply: '$rm $rs - $rr' from user $fu, source address $si:$sp \n");

    if (!t_check_trans()) drop();

    if(status=~"[12][0-9][0-9]") {
        route(HANDLE_NAT_REPLY);
    }

    xlog("[ONREPLY_ROUTE] Value for: directly_reply_response is - $avp(directly_reply_response)");
    if($avp(directly_reply_response) == "true") { ## TODO: Improve... This logic is used, when we receive the transaction response, in the "real" instance where the connection lives, but when its not the case, we need avoid this, and relay the response normally to all proxies in the middle, also add logic to enter only also on TCP/TLS/WSS scenarios

        route(PREPARE_RESPONSE_TO_BE_SENT_INTERNALLY);
        route(PREPARE_RESPONSE_WITHOUT_INTERNAL_HOP);
        xlog("[ONREPLY_ROUTE] I'm fucking here - to $du");
        ##msg_apply_changes();
    }

    #!ifdef WITH_RTPENGINE
        route(RTPENGINE_MANAGE);
    #!endif

}

route[PREPARE_RESPONSE_WITHOUT_INTERNAL_HOP] {
        $vn(updated_destination_for_response) = "sip:" + $sel(@via[3].host) + ":" + $sel(@via[3].port); ## for better received and rport should be also checked and preferred
        remove_hf_value("Via[2]");
}

## for happy SIP Flow
route[PREPARE_RESPONSE_TO_BE_SENT_INTERNALLY] {
    $var(copy_response_to_sent_internally) = $mb;
    $var(remove_last_header_comma) = $(sel(@via[2]){re.subst,/,//g});
    $var(via_to_be_mantained_to_send_internally) = "Via: " + $var(remove_last_header_comma);
    $vn(internal_hop_for_happy_signaling) = "sip:" + $sel(@via[2].received) + ":" + $sel(@via[2].port); ## for better received and rport should be also checked and preferred

    $var(copy_response_to_sent_internally) = $(var(copy_response_to_sent_internally){re.subst,/Via:.*//g});
    $var(copy_response_to_sent_internally) = $(var(copy_response_to_sent_internally){re.subst,/Content-Length.*([[:digit:]]{1,})/Content-Length: \1/g});
    $var(copy_response_to_sent_internally) = $var(copy_response_to_sent_internally) + $var(via_to_be_mantained_to_send_internally);
    $var(copy_response_to_sent_internally) = $(var(copy_response_to_sent_internally){re.subst,/[[:space:]]{2,}/\r\n/gs});
    $var(copy_response_to_sent_internally) = $(var(copy_response_to_sent_internally){re.subst,/[[:space:]]{2,}/\r\n/gs});
    $var(copy_response_to_sent_internally) = $var(copy_response_to_sent_internally) + "\r\n\r\n";

    ## example for testing purposes
    /*$var(copy_response_to_sent_internally) =
        "SIP/2.0 200 OK\r\n"
        "Via: SIP/2.0/UDP kamailio.cluster:5060;received=172.25.0.4;branch=z9hG4bK46d5.75b0962c51f6bbbd7a5c9faca9075d61.0;i=3\r\n"
        "From: \"111111112\" <sip:111111112@172.25.0.10>;tag=1\r\n"
        "To: \"111111111\" <sip:111111111@172.25.0.12>;tag=1SIPpTag001\r\n"
        "Call-ID: 1-1@172.25.0.10\r\n"
        "CSeq: 2 BYE\r\n"
        "Contact: <sip:111111112@172.25.0.12:5060;transport=TCP>\r\n"
        "Content-Type: application/sdp\r\n"
        "Content-Length:     0\r\n\r\n";*/
}
