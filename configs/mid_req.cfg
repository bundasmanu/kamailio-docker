
mid_req.reason_invalid_in_dialog_req = "Bad Request"
mid_req.sip_code_invalid_in_dialog_req = 400

route[MID_REQUEST] {

    if (!has_totag()) return;

    xlog("L_NOTICE", "[MID_REQUEST] Received a mid-request: $rm $ru from $si \n");

    if (is_method("INVITE|BYE|REFER|ACK|UPDATE|PRACK")){
        dlg_manage();
        route(SOURCE_ADDR_IS_EXTERNAL);
    }

    route(RE_ROUTING_INTERNAL_ON_FAILED_INSTANCE);

    if (loose_route()) {

        if ($sht(params=>nat_contact:$si) == 1 || $sht(params=>nat_contact:$fd) == 1 || $sht(params=>nat_contact:$td) == 1 || $sel(cfg_get.nat.up) == 1) {
            handle_ruri_alias();
        }

        if(is_method("REFER|INFO|NOTIFY|UPDATE|INVITE|SUBSCRIBE")) {
            route(RECORD_ROUTE);
        }

        route(RELAY);

        exit;

    }

    ## re-routing logic
    if ($vn(force_failover_dest) != $null) {
        $du = $sel(ruri);
        route(RELAY);
        exit;
    }

    ## ACK hop by hop
    if(is_method("ACK")) {
        if (t_check_trans()) {
            xlog("L_NOTICE", "[MID_REQUEST] received an hop-by-hop request: $rm \n");
            route(RELAY);
        } else {
            xlog("L_NOTICE", "[MID_REQUEST] received an $rm without any transaction associated, let's drop it. \n");
        }
        exit;
    }

    ## Let's provide a stateless response, if we can't deal with a invalid in-dialog request
    sl_send_reply("$ccp(mid_req.sip_code_invalid_in_dialog_req)", "$ccp(mid_req.reason_invalid_in_dialog_req)");
    exit;

}

## Route used to check if the next hop is to an internal kam instance different from this one, if yes, stop the route to that instance
route[RE_ROUTING_INTERNAL_ON_FAILED_INSTANCE] {

    if(is_request() && search_hf("Route", ";edge_proxy=yes", "f")) {
        $var(route_header) = $(hdr(Route)[0]);
        $var(route_host) = $(var(route_header){nameaddr.uri}{uri.host});
        if (!is_myself("$var(route_host)")) {
            xlog("L_WARN", "Removed Route header - Failover case - Let's re-routing. Removed Route header: $var(route_header) ");
            remove_hf("Route");
            msg_apply_changes();
            $vn(force_failover_dest) = "yes"; ## but loose_route needs to be checked first, other Route headers could exist
        }
    }

}
